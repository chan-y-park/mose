import logging
import ast
from misc import deep_reverse
from numpy import array
from zones import orbit_is_contained, unite_orbits
from cmath import phase, pi


### IF TOO LARGE, IT WILL PRODUCE THOSE SECANTS 
### IN THE INTERPOLATION OF INTERSECTION POINTS
### TO MAKE A MS-WALL.
### IF TOO SMALL, WE WILL LOSE POINTS ON THE MS-WALL.
SEARCH_RANGE_RATIO = 0.15 

class MarginalStabilityWall:
    """
    Th MS wall class.
    Attributes:
    charges, degeneracy -- those of (any) two K-walls meeting theta_range
    points -- the list of actual intersectionpoint objects
    locus -- the list of points (UNSORTED FOR NOW)
    genealogy -- that of any intersection making up the wall

    Note: intersections are sorted following the arc traced by the ms-wall, 
    moreover (depending on the case) MS walls are enhanced with singularities 
    on which they end. 
    Such singularities are added at the end of the argument all_intersections, 
    they are given as instances of the branch-point class, and are NOT 
    converted to intersection-point objects.
    """

    count = 0

    def __init__(self, all_intersections, fibration, charge_orbit):
        ### !!! CONCEPTUALLY WRONG !!! 
        ### An MS wall doenst have a single pair of charges, 
        ### but rather several pairs, related by monodromies!
        ### Improve this piece of data.!
        self.gauge_charges = all_intersections[0].gauge_charges 
        self.flavor_charges = all_intersections[0].flavor_charges 

        ### The charge orbit of an MS wall, like that of an
        ### intersection point, is a list of elements
        ### [... , [[g1, g2], [f1, f2]] , ...]
        ### where g1, g2 are the gauge charges of the parent kwalls
        ### while f1, f2 are their flavor charges.
        ### The list contains elements of an orbit of these charges
        ### by the SL(2,Z) subgroup generated by the monodromies.
        ### By construction, the charge orbit of an MS wall 
        ### is larger or equal to the orbits of all it intersection
        ### points.
        self.charge_orbit = charge_orbit

        self.degeneracies = all_intersections[0].degeneracies
        self.genealogy = all_intersections[0].genealogy
        self.fibration = fibration
        self.points = all_intersections
        self.delete_duplicate_points()     
        ### Now we reorder the list of self.points,
        ### according to the actual shape of the wall
        self.reorganize()
        ### the following enhances the self.points attribute, 
        ### possibly by adding branch-points
        self.enhance_ms_wall()
        self.locus = [point.locus for point in self.points]
        MarginalStabilityWall.count += 1

    def delete_duplicate_points(self):
        seen = set()
        uniq = []
        for x in self.points:
            if x.locus not in seen:
                uniq.append(x)
                seen.add(x.locus)
        self.points = uniq

    def enhance_ms_wall(self):
        ### now we add branch-points if they belong to the MS-walls,
        ### this is determined by wether BOTH the parents of the MS-wall
        ### are primary kwalls.
        a_random_point = self.points[0]
        kwall_0, kwall_1 = a_random_point.parents

        if kwall_0.__class__.__name__ == 'PrimaryKWall' \
                    and kwall_1.__class__.__name__ == 'PrimaryKWall':
            branch_point_0 = kwall_0.parents[0]
            branch_point_1 = kwall_1.parents[0]
            self.points.append(branch_point_0)
            self.points.append(branch_point_1)
    
    ### OLD METHOD: This starts from the leftmost point (smallest Real part)
    ### of the intersection points of the MS wall, then tracks the 
    ### upper and lower arcs separately, by looking repeatedly for the 
    ### nearest neighbor, within a certain radius that we specify.
    # def reorganize(self):
    #     """
    #     MS walls are arcs, this function reorders the intersections, 
    #     following the arc.
    #     """
    #     if len(self.points) <= 2:
    #         pass

    #     else:
    #         points_copy = [pt for pt in self.points]
    #         leftmost_point = sorted(points_copy, key=getkey_real)[0]
    #         max_distance = max([abs(pt_1.locus - pt_2.locus) \
    #                                             for pt_1 in self.points \
    #                                             for pt_2 in self.points])    
    #         min_distance = min([abs(pt_1.locus - pt_2.locus) \
    #                                             for pt_1 in self.points \
    #                                             for pt_2 in self.points \
    #                                             if pt_1.locus != pt_2.locus])    

    #         search_range = SEARCH_RANGE_RATIO * max_distance

    #         self.semi_arc_1 = []
    #         self.semi_arc_2 = []

    #         seen = [leftmost_point.locus]
            
    #         ### Build the first semi-arc
    #         current_point = leftmost_point
    #         arc_is_finished = False
    #         while not arc_is_finished:
    #             found_new_closest_point = False
    #             epsilon = search_range
    #             for pt in self.points:
    #                 distance = abs(pt.locus - current_point.locus)
    #                 if distance < epsilon and (not (pt.locus in seen)): 
    #                     ### Now we check that when we actually
    #                     ### get at the end of the semi-arc 1, we don't 
    #                     ### switch to the beginning of the semi-arc 2.
    #                     ### The check involves comparing the distance
    #                     ### pt - current_point
    #                     ### with
    #                     ### current_point - leftmost_locus
    #                     ### The former should be smaller than the latter
    #                     ### However, we must skip this check at the 
    #                     ### very beginning, because in that case
    #                     ### current_point = leftmost_locus!
    #                     if current_point.locus != leftmost_point.locus:
    #                         if (distance <= abs(pt.locus \
    #                                                 - leftmost_point.locus)):
    #                             found_new_closest_point = True
    #                             epsilon = distance
    #                             closest_point = pt
    #                         else:
    #                             pass
    #                     else:
    #                         found_new_closest_point = True
    #                         epsilon = distance
    #                         closest_point = pt

    #             if found_new_closest_point == False:
    #                 arc_is_finished = True
    #             else:
    #                 seen.append(closest_point.locus)
    #                 self.semi_arc_1.append(closest_point)
    #                 current_point = closest_point

    #         ### Build the second semi-arc
    #         current_point = leftmost_point
    #         arc_is_finished = False
    #         while not arc_is_finished:
    #             found_new_closest_point = False
    #             epsilon = search_range
    #             for pt in self.points:
    #                 distance = abs(pt.locus - current_point.locus)
    #                 if distance < epsilon and not (pt.locus in seen):
    #                     found_new_closest_point = True
    #                     epsilon = distance
    #                     closest_point = pt

    #             if found_new_closest_point == False:
    #                 arc_is_finished = True
    #             else:
    #                 seen.append(closest_point.locus)
    #                 self.semi_arc_2.append(closest_point)
    #                 current_point = closest_point

    #         reorganized_points = self.semi_arc_1[::-1] + [leftmost_point] \
    #                                                         + self.semi_arc_2
    #         if len(reorganized_points) == len(self.points):
    #             self.points = reorganized_points
    #             pass
    #         else:
    #             self.points = reorganized_points
    #             print "\n IN WALL #%s" % self.count
    #             print "\noriginal points"
    #             # print self.points
    #             print [x.locus for x in self.points]
    #             print "\nreorganized points"
    #             # print reorganized_points
    #             print [x.locus for x in reorganized_points]
    #             logging.info('Lost some of the MS Wall points '\
    #                                 + 'while reorganizing it.\n' \
    #                                 + 'Try increasing the search radius.')
    
    ### INCOMPLETE
    # ### NEW METHOD: This splits the MS wall into several arcs, splitting
    # ### the MS wall at turning points (dx/dt=0 or dy/dt=0); then it tracks 
    # ### sorts the points in each arc separately. 
    # ### The sorting is done by simply sorting the points in each arc 
    # ### by their real part, or imaginary part.

    # def reorganize(self):
    #     """
    #     MS walls are arcs, this function reorders the intersections, 
    #     following the arc.
    #     """
    #     if len(self.points) <= 2:
    #         pass

    #     else:
    #         all_arcs = []
    #         points_copy = [pt for pt in self.points]
    #         leftmost_point = sorted(points_copy, key=getkey_real)[0]

    #         ### Now decide whether to go clockqise or counterclockwise
    #         ### this step is necessary, because it may happen
    #         ### that the leftmost point is one tip of the MS wall.
    #         closest_to_leftmost = sorted(
    #                         [[pt, abs(pt.locus - leftmost_point.locus)] \
    #                         for points_copy if pt.locus!=leftmost_point.locus], 
    #                         key=getkey_second
    #                         )[0][0]
    #         delta_y = closest_to_leftmost.locus.imag 
    #                                             - leftmost_point.locus.imag
    #         if delta_y > 0:
    #             direction = 'cw'
    #             sector = 'NW'
    #         elif delta_y < 0:
    #             direction = 'ccw'
    #             sector = 'SW'
    #         elif delta_y == 0:
    #             raise ValueError('cannot detemine the direction to take ' \
    #                             + 'in sorting the MS wall')

    #         remaining_points = [pt for pt in self.points]
    #         while len(remaining_points) > 0:
    #             arc, remaining_points = build_arc(remaining_points, sector)
    #             all_arcs.append(arc)

    #         ### CAN'T START FROM THE LEFTMOST POINT
    #         ### NEED TO FIND THE ENDPOINT, SOMEHOW
    #         .....

    #         reorganized_points = []
    #         for arc in all_arcs:
    #             reorganized_points = reorganized_points + arc

    #         if len(reorganized_points) == len(self.points):
    #             self.points = reorganized_points
    #             pass
    #         else:
    #             print "\n IN WALL #%s" % self.count
    #             print "\noriginal points"
    #             # print self.points
    #             print [x.locus for x in self.points]
    #             print "\nreorganized points"
    #             # print reorganized_points
    #             print [x.locus for x in reorganized_points]
    #             logging.info('Lost some of the MS Wall points '\
    #                                 + 'while reorganizing it.')

    ### NEW METHOD: an MS wall is assumed to have the shape of an arc, 
    ### we fix a point somewhere in the middle of it, and sort 
    ### all the intersection points accordint to the phase of the 
    ### radius connecting them to the basepoint.
    ### Then, we figure out where are the endpoints and reorganize 
    ### accordingly.

    def reorganize(self):
        """
        MS walls are arcs, this function reorders the intersections, 
        following the arc.
        """
        if len(self.points) <= 2:
            pass

        else:
            basepoint = sum[pt.leftmost_locus for pt in self.points] \
                                                            / len(self.points)
            
            phase_sorted_pts = [x[0] for x in sorted(
                                    [[pt, phase(pt.locus - basepoint)] \
                                    for pt in self.points], key=getkey_second)
                                ]

            gap_start, gap_end = find_phase_gap(phase_sorted_pts, basepoint)

            ### If the gap lies across the negative real axis, then 
            ### our points are already sorted correctly
            if:
                gap_start == len(phase_sorted_pts) and gap_end == 0:
                self.points = phase_sorted_pts

            ### Otherwise we need to cut-and-paste
            else:
                ### recall that the phase is defined between -pi and pi,
                ### so we should cut and paste accordingly
                reorganized_points = phase_sorted_pts[gap_end, -1] \
                                                + phase_sorted_pts[0:gap_start+1]

                if len(reorganized_points) == len(self.points):
                    self.points = reorganized_points
                    pass
                else:
                    self.points = reorganized_points
                    print "\n IN WALL #%s" % self.count
                    print "\noriginal points"
                    # print self.points
                    print [x.locus for x in self.points]
                    print "\nreorganized points"
                    # print reorganized_points
                    print [x.locus for x in reorganized_points]
                    logging.info('Lost some of the MS Wall points '\
                                        + 'while reorganizing it.')


def find_phase_gap(phase_sorted_pts, basepoint):
    ### we compute first the phase gap between the
    ### points across the negative real axis
    pt_0 = phase_sorted_pts[0]
    pt_1 = phase_sorted_pts[-1]
    phase_gap = 2.0 * pi + phase(pt_0.locus - basepoint) \
                                                - phase(pt_1.locus - basepoint)
    gap_start = len(phase_sorted_pts)
    gap_end = 0

    ### Then we study angle differences between consecutive 
    ### intersection points, and check if any of these
    ### is larger than the above phase-gap.
    angle = phase(pt_0.locus - basepoint)
    for i, pt in enumerate(phase_sorted_pts):
        new_angle = phase(pt.locus - basepoint)
        delta_angle = new_angle - angle
        angle = new_angle
        if delta_angle > phase_gap:
            phase_gap = delta_angle
            gap_start = i - 1
            gap_end = i

    return gap_start, gap_end



# def following_sector(direction, sector):
#     if direction == 'cw':
#         if sector == 'NW':
#             return 'NE'
#         elif sector == 'NE':
#             return 'SE'
#         elif sector == 'SE':
#             return 'SW'
#         elif sector == 'SW':
#             return 'NW'
#         else:
#             raise ValueError('Invalid sector name.')

#     elif direction == 'ccw':
#         if sector == 'NW':
#             return 'SW'
#         elif sector == 'SW':
#             return 'SE'
#         elif sector == 'SE':
#             return 'NE'
#         elif sector == 'NE':
#             return 'NW'
#         else:
#             raise ValueError('Invalid sector name.')

#     else:
#         raise ValueError('Invalid direction name.')


def getkey_real(int_point):
    return int_point.locus.real


def getkey_second(x):
    return x[1]


def build_ms_walls(k_wall_networks):
    """
    This function creates MS walls, by sifting through all the intersections.
    These are clustered accoding to a certain choice of data.
    """
    all_intersections = []
    fibration = k_wall_networks[0].fibration
    for kwn in k_wall_networks:
        all_intersections += kwn.intersections
    
    ### OLD METHOD, USED THE GENEALOGY
    # ### to distinguish wall types, use the genealogy data
    # data = [x.genealogy for x in all_intersections]

    ### NEW METHOD: CHARGE ORBITS
    data = [x.charge_orbit for x in all_intersections]

    seen = []
    walls = []

    logging.info(
                    '-----------------\n'
                    'Building MS walls\n'
                    '-----------------'
                )

    for i in range(len(data)):
        i_th_charge_orbit = data[i]
        check = orbit_is_contained(seen, i_th_charge_orbit)
        if check == 'not contained':
            walls.append([all_intersections[i]]) #start a new wall
            seen.append(i_th_charge_orbit)
        else:
            index = check
            ### we possibly enlarge the reference 'seen' orbit 
            ### by taking the union with this one
            seen[index] = unite_orbits(seen[index], i_th_charge_orbit)
            ### then we add this intersection point to the corresponding
            ### marginal stability wall
            walls[index].append(all_intersections[i])

    ### MS walls need to have a charge orbit assigned to them
    ### the i-th 'seen' orbit corresponds by construction to the 
    ### i-th MS wall, and it is the union of the orbits
    ### of all its intersection points.
    return [MarginalStabilityWall(x, fibration, seen[i]) \
                                                for i, x in enumerate(walls)]


